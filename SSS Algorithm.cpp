#include<iostream>
#include<vector>
#include<ctime>
#include<cassert>
#include<sstream>
#include<string>
using namespace std;
const int shares = 4;
const int threshold = 2;
const int PRIME = 2;
// The algorithm uses GF(256) and uses generator to do calculations
// The below LOG and EXP table are taken in hexadecimal to ease calculations and increase speed of calculations
// Ref - http://www.cs.utsa.edu/~wagner/laws/FFM.html
const unsigned int LOG[] = {
     0xff,  0x00,  0x19,  0x01,  0x32,  0x02,  0x1a,
     0xc6,  0x4b,  0xc7,  0x1b,  0x68,  0x33,  0xee,
     0xdf,  0x03,  0x64,  0x04,  0xe0,  0x0e,  0x34,
     0x8d,  0x81,  0xef,  0x4c,  0x71,  0x08,  0xc8,
     0xf8,  0x69,  0x1c,  0xc1,  0x7d,  0xc2,  0x1d,
     0xb5,  0xf9,  0xb9,  0x27,  0x6a,  0x4d,  0xe4,
     0xa6,  0x72,  0x9a,  0xc9,  0x09,  0x78,  0x65,
     0x2f,  0x8a,  0x05,  0x21,  0x0f,  0xe1,  0x24,
     0x12,  0xf0,  0x82,  0x45,  0x35,  0x93,  0xda,
     0x8e,  0x96,  0x8f,  0xdb,  0xbd,  0x36,  0xd0,
     0xce,  0x94,  0x13,  0x5c,  0xd2,  0xf1,  0x40,
     0x46,  0x83,  0x38,  0x66,  0xdd,  0xfd,  0x30,
     0xbf,  0x06,  0x8b,  0x62,  0xb3,  0x25,  0xe2,
     0x98,  0x22,  0x88,  0x91,  0x10,  0x7e,  0x6e,
     0x48,  0xc3,  0xa3,  0xb6,  0x1e,  0x42,  0x3a,
     0x6b,  0x28,  0x54,  0xfa,  0x85,  0x3d,  0xba,
     0x2b,  0x79,  0x0a,  0x15,  0x9b,  0x9f,  0x5e,
     0xca,  0x4e,  0xd4,  0xac,  0xe5,  0xf3,  0x73,
     0xa7,  0x57,  0xaf,  0x58,  0xa8,  0x50,  0xf4,
     0xea,  0xd6,  0x74,  0x4f,  0xae,  0xe9,  0xd5,
     0xe7,  0xe6,  0xad,  0xe8,  0x2c,  0xd7,  0x75,
     0x7a,  0xeb,  0x16,  0x0b,  0xf5,  0x59,  0xcb,
     0x5f,  0xb0,  0x9c,  0xa9,  0x51,  0xa0,  0x7f,
     0x0c,  0xf6,  0x6f,  0x17,  0xc4,  0x49,  0xec,
     0xd8,  0x43,  0x1f,  0x2d,  0xa4,  0x76,  0x7b,
     0xb7,  0xcc,  0xbb,  0x3e,  0x5a,  0xfb,  0x60,
     0xb1,  0x86,  0x3b,  0x52,  0xa1,  0x6c,  0xaa,
     0x55,  0x29,  0x9d,  0x97,  0xb2,  0x87,  0x90,
     0x61,  0xbe,  0xdc,  0xfc,  0xbc,  0x95,  0xcf,
     0xcd,  0x37,  0x3f,  0x5b,  0xd1,  0x53,  0x39,
     0x84,  0x3c,  0x41,  0xa2,  0x6d,  0x47,  0x14,
     0x2a,  0x9e,  0x5d,  0x56,  0xf2,  0xd3,  0xab,
     0x44,  0x11,  0x92,  0xd9,  0x23,  0x20,  0x2e,
     0x89,  0xb4,  0x7c,  0xb8,  0x26,  0x77,  0x99,
     0xe3,  0xa5,  0x67,  0x4a,  0xed,  0xde,  0xc5,
     0x31,  0xfe,  0x18,  0x0d,  0x63,  0x8c,  0x80,
     0xc0,  0xf7,  0x70,  0x07,
  };
const unsigned int EXP[] = {
     0x01,  0x03,  0x05,  0x0f,  0x11,  0x33,  0x55,
     0xff,  0x1a,  0x2e,  0x72,  0x96,  0xa1,  0xf8,
     0x13,  0x35,  0x5f,  0xe1,  0x38,  0x48,  0xd8,
     0x73,  0x95,  0xa4,  0xf7,  0x02,  0x06,  0x0a,
     0x1e,  0x22,  0x66,  0xaa,  0xe5,  0x34,  0x5c,
     0xe4,  0x37,  0x59,  0xeb,  0x26,  0x6a,  0xbe,
     0xd9,  0x70,  0x90,  0xab,  0xe6,  0x31,  0x53,
     0xf5,  0x04,  0x0c,  0x14,  0x3c,  0x44,  0xcc,
     0x4f,  0xd1,  0x68,  0xb8,  0xd3,  0x6e,  0xb2,
     0xcd,  0x4c,  0xd4,  0x67,  0xa9,  0xe0,  0x3b,
     0x4d,  0xd7,  0x62,  0xa6,  0xf1,  0x08,  0x18,
     0x28,  0x78,  0x88,  0x83,  0x9e,  0xb9,  0xd0,
     0x6b,  0xbd,  0xdc,  0x7f,  0x81,  0x98,  0xb3,
     0xce,  0x49,  0xdb,  0x76,  0x9a,  0xb5,  0xc4,
     0x57,  0xf9,  0x10,  0x30,  0x50,  0xf0,  0x0b,
     0x1d,  0x27,  0x69,  0xbb,  0xd6,  0x61,  0xa3,
     0xfe,  0x19,  0x2b,  0x7d,  0x87,  0x92,  0xad,
     0xec,  0x2f,  0x71,  0x93,  0xae,  0xe9,  0x20,
     0x60,  0xa0,  0xfb,  0x16,  0x3a,  0x4e,  0xd2,
     0x6d,  0xb7,  0xc2,  0x5d,  0xe7,  0x32,  0x56,
     0xfa,  0x15,  0x3f,  0x41,  0xc3,  0x5e,  0xe2,
     0x3d,  0x47,  0xc9,  0x40,  0xc0,  0x5b,  0xed,
     0x2c,  0x74,  0x9c,  0xbf,  0xda,  0x75,  0x9f,
     0xba,  0xd5,  0x64,  0xac,  0xef,  0x2a,  0x7e,
     0x82,  0x9d,  0xbc,  0xdf,  0x7a,  0x8e,  0x89,
     0x80,  0x9b,  0xb6,  0xc1,  0x58,  0xe8,  0x23,
     0x65,  0xaf,  0xea,  0x25,  0x6f,  0xb1,  0xc8,
     0x43,  0xc5,  0x54,  0xfc,  0x1f,  0x21,  0x63,
     0xa5,  0xf4,  0x07,  0x09,  0x1b,  0x2d,  0x77,
     0x99,  0xb0,  0xcb,  0x46,  0xca,  0x45,  0xcf,
     0x4a,  0xde,  0x79,  0x8b,  0x86,  0x91,  0xa8,
     0xe3,  0x3e,  0x42,  0xc6,  0x51,  0xf3,  0x0e,
     0x12,  0x36,  0x5a,  0xee,  0x29,  0x7b,  0x8d,
     0x8c,  0x8f,  0x8a,  0x85,  0x94,  0xa7,  0xf2,
     0x0d,  0x17,  0x39,  0x4b,  0xdd,  0x7c,  0x84,
     0x97,  0xa2,  0xfd,  0x1c,  0x24,  0x6c,  0xb4,
     0xc7,  0x52,  0xf6,  0x01,  0x03,  0x05,  0x0f,
     0x11,  0x33,  0x55,  0xff,  0x1a,  0x2e,  0x72,
     0x96,  0xa1,  0xf8,  0x13,  0x35,  0x5f,  0xe1,
     0x38,  0x48,  0xd8,  0x73,  0x95,  0xa4,  0xf7,
     0x02,  0x06,  0x0a,  0x1e,  0x22,  0x66,  0xaa,
     0xe5,  0x34,  0x5c,  0xe4,  0x37,  0x59,  0xeb,
     0x26,  0x6a,  0xbe,  0xd9,  0x70,  0x90,  0xab,
     0xe6,  0x31,  0x53,  0xf5,  0x04,  0x0c,  0x14,
     0x3c,  0x44,  0xcc,  0x4f,  0xd1,  0x68,  0xb8,
     0xd3,  0x6e,  0xb2,  0xcd,  0x4c,  0xd4,  0x67,
     0xa9,  0xe0,  0x3b,  0x4d,  0xd7,  0x62,  0xa6,
     0xf1,  0x08,  0x18,  0x28,  0x78,  0x88,  0x83,
     0x9e,  0xb9,  0xd0,  0x6b,  0xbd,  0xdc,  0x7f,
     0x81,  0x98,  0xb3,  0xce,  0x49,  0xdb,  0x76,
     0x9a,  0xb5,  0xc4,  0x57,  0xf9,  0x10,  0x30,
     0x50,  0xf0,  0x0b,  0x1d,  0x27,  0x69,  0xbb,
     0xd6,  0x61,  0xa3,  0xfe,  0x19,  0x2b,  0x7d,
     0x87,  0x92,  0xad,  0xec,  0x2f,  0x71,  0x93,
     0xae,  0xe9,  0x20,  0x60,  0xa0,  0xfb,  0x16,
     0x3a,  0x4e,  0xd2,  0x6d,  0xb7,  0xc2,  0x5d,
     0xe7,  0x32,  0x56,  0xfa,  0x15,  0x3f,  0x41,
     0xc3,  0x5e,  0xe2,  0x3d,  0x47,  0xc9,  0x40,
     0xc0,  0x5b,  0xed,  0x2c,  0x74,  0x9c,  0xbf,
     0xda,  0x75,  0x9f,  0xba,  0xd5,  0x64,  0xac,
     0xef,  0x2a,  0x7e,  0x82,  0x9d,  0xbc,  0xdf,
     0x7a,  0x8e,  0x89,  0x80,  0x9b,  0xb6,  0xc1,
     0x58,  0xe8,  0x23,  0x65,  0xaf,  0xea,  0x25,
     0x6f,  0xb1,  0xc8,  0x43,  0xc5,  0x54,  0xfc,
     0x1f,  0x21,  0x63,  0xa5,  0xf4,  0x07,  0x09,
     0x1b,  0x2d,  0x77,  0x99,  0xb0,  0xcb,  0x46,
     0xca,  0x45,  0xcf,  0x4a,  0xde,  0x79,  0x8b,
     0x86,  0x91,  0xa8,  0xe3,  0x3e,  0x42,  0xc6,
     0x51,  0xf3,  0x0e,  0x12,  0x36,  0x5a,  0xee,
     0x29,  0x7b,  0x8d,  0x8c,  0x8f,  0x8a,  0x85,
     0x94,  0xa7,  0xf2,  0x0d,  0x17,  0x39,  0x4b,
     0xdd,  0x7c,  0x84,  0x97,  0xa2,  0xfd,  0x1c,
     0x24,  0x6c,  0xb4,  0xc7,  0x52,  0xf6,
  };

// Base is 2 so addition is simply xor
static int add(const int &a,const int &b)
{
    return (a^b);
}
// Subtration is addition in base 2
static int sub(const int &a,const int &b)
{
    return add(a,b);
}
// Multiplication using finite arithmatic
static int mul(const int &a,const int &b)
{
    if(!a || !b)
        return 0;
    return EXP[(unsigned int)(LOG[(unsigned int)(a)]) + (unsigned int)(LOG[(unsigned int)(b)])];
}
// Division needs to multiply inverse modulo of b
static int divi(const int &a,const int &b)
{
    return mul(a, EXP[255 - (unsigned int)(LOG[(unsigned int)(b)])]);
}
// Evaluate Polynomial passed to the function
// vector p contains coefficients
// x is the value given to the variables
static int eval(vector <unsigned int> p, unsigned int x) {
    // Horner's method
    unsigned int result = 0;
    for (int i = (int)p.size() - 1; i >= 0; i--) {
      result = add(mul(result, x), p[i]);
    }
    return result;
}
// Calclates degree of an polynomial
static int degree(vector <unsigned int> p) {
    for (int i = p.size() - 1; i >= 1; i--) {
      if (p[i] != 0) {
        return i;
      }
    }
    return 0;
  }
// generate random polynomials of given degree, x is the secret to be encoded
vector <unsigned int> generate(int degree, unsigned int x) {
    vector <unsigned int> p(degree+1,0);

    // generate random polynomials until we find one of the given degree
    for(int i=1;i<p.size();i++)
    {
        srand(time(0));
        p[i] = rand()%256;
    }
    // set y intercept
    p[0] = x;
    return p;
  }
// Uses Lagrange's interpolation to calculate secret from given shares
static unsigned int interpolate(vector <vector<unsigned int> > points)
{
    // calculate f(0) of the given points using Lagrangian interpolation
    unsigned int x = 0;
    unsigned int y = 0;
    for (int i = 0; i < points.size(); i++) {
      unsigned int aX = points[i][0];
      unsigned int aY = points[i][1];
      unsigned int li = 1;
      for (int j = 0; j < points.size(); j++) {
        unsigned int bX = points[j][0];
        if (i != j) {
          li = mul(li, divi(sub(x, bX), sub(aX, bX)));
        }
      }
      y = add(y, mul(li, aY));
    }
    return y;
}
// Generates shares using above function and return it
vector <vector<unsigned int> > encode(string secret) {
    // generate part values
    int n = secret.size();
    vector <vector <unsigned int> > values(shares);
    for (int i = 0; i < n; i++) {
      // for each byte, generate a random polynomial, p
      vector <unsigned int> p = generate(threshold - 1, (unsigned int)secret[i]);
      for (int x = 1; x <= shares; x++) {
        // each part's byte is p(partId)
        values[x - 1].push_back(eval(p, (unsigned int)x));
      }
    }

    // return as a set of objects
    vector <vector<unsigned int> > parts;
    for (int i = 0; i < values.size(); i++) {
      parts.push_back(values[i]);
    }
    return parts;
  }
// Takes threshold amount of shares and returns the secret
// Incase of mismatch or invalid shares, it will return garbage values
string decode(vector <vector <unsigned int> > parts,vector <unsigned int> nums) {
    assert((int)parts.size() >= threshold);
    int length = parts[0].size();
    for(int i=1;i<parts.size();i++)
    {
        assert((int)parts[i].size() == length);
    }
    string secret(length,' ');
    for (int i = 0; i < length; i++) {
      vector <vector <unsigned int> > points(threshold);
      for(int j=0;j<threshold;j++)
      {
          points[j].push_back(nums[j]);
          points[j].push_back(parts[j][i]);
      }
      secret[i] = (char)interpolate(points);
    }
    return secret;
  }
int main()
{
    int ch;
    cout<<" Shares = "<<shares<<", Threshold = "<<threshold<<"\n";
    cout<<"---------------------------- SSS Algorithm Menu -------------------------------\n";
    cout<<"1. Generate Shares\n";
    cout<<"2. Retrieve Secret\n";
    cout<<"3. Exit\n";
    cin>>ch;
    switch(ch)
    {
        // Generates shares in the form of (x, y1-y2-y3-y4....yn)
        case 1:
            {
            string secret;
            cout<<"Enter Secret=";
            fflush(stdin);
            getline(cin,secret);
            cout.flush();
            cout.flush();
            vector <vector <unsigned int> > all_shares = encode(secret);
            cout.flush();
            for(int i=0;i<all_shares.size();i++)
            {
                cout<<"Share "<<i+1<<" : ("<<i+1<<" , ";
                for(int j=0;j<all_shares[i].size();j++)
                    cout<<all_shares[i][j]<<"-)"[j==all_shares[i].size()-1];
                cout<<endl;
            }
            break;
            }
        case 2:
            {
            // takes input in the form of x coordinate and y coordinate
            cout<<"Enter "<<threshold<<" shares:\n";
            vector <unsigned int> nums(threshold,0);
            vector <vector <unsigned int> > parts(threshold);
            for(int i=0;i<threshold;i++)
            {
                cout<<"Enter x-coordinate = ";
                cin>>nums[i];
                cout<<"Enter y-coordinate (y1-y2-y3-y4....yn)= ";
                string y;
                cin>>y;
                stringstream ss(y);
                vector <unsigned int> tmp;
                for(int j;ss>>j;){
                    while(ss.peek()=='-' || ss.peek()==' ')
                        ss.ignore();
                    tmp.push_back(j);
                    while(ss.peek()=='-' || ss.peek()==' ')
                        ss.ignore();
                }
                parts[i] = tmp;
            }
            cout<<"The secret message is : "<<decode(parts,nums)<<endl;
            break;
            }
        case 3: exit(0);
                break;
        default: cout<<"Undefined Input"<<endl;
    }
}
